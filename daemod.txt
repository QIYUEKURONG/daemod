守护进程就是运行在后台的一种特殊的进程。
它独立于控制终端并且周期性地执行某种任务或等待。

Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器inetd，Web服务器httpd等。
同时，守护进程完成许多系统任务。比如，作业规划进程crond，打印进程lpd等。

进程组和会话
进程组是一组相关进程的集合，会话是一组相关进程组的集合。
进程组的好处：
这项工作放弃了，不必给每一个进程一一发送信号，
可以直接发送给进程组，进程组内的进程都会收到的，。

PID:进程的唯一标识。
PGID:进程组的ID。
每个进程都会有进程组ID，表示该进程所属的进程组。
默认情况下新创建的进程会继承父进程的进程组ID
SID:会话ID。
每个进程也都有会话ID。默认情况下，新创建的进程会继承父进程的会话ID。

进程组和会话是为了支持shell作业控制而引入的概念。

一个进程只能为它自己或子进程设置进程组ID号。
1:只有在前台进程组中进程才能在控制终端读取输入，
2:当用户在终端输入信号生成终端字符（如ctrl+c、ctrl+z、ctr+\等）时，对应的信号只会发送给前台进程组。
3:会话的意义在于将很多的工作囊括在一个终端，
选取其中一个作为前台来直接接收终端的输入及信号，其他的工作则放在后台执行。

函数setsid()可以建立一个对话期。
如果使用这个函数的进程不是一个进程组的组长，此函数
创建一个新的会话期，而且此进程。
    (1)此进程变成该对话期的首进程
    (2)此进程变成一个新进程组的组长进程。
    (3)此进程没有控制终端，如果在调用setsid前，该进程有控制终端，那么与该终端的联系被解除。
    (4)为了保证这一点，我们先调用fork()然后exit()，此时只有子进程在运行，
    子进程继承了父进程的进程组ID，但是进程PID却是新分配的，所以不可能是新会话的进程组的PID。
    从而保证了这一点。
	如果该进程是一个进程组的组长，此函数返回错误

	守护进程
	1：后台运行
	为避免挂起控制终端将Daemon放入后台执行。方法是在进程中调用fork使父进程终止，
    让Daemon在子进程中后台执行。

	2：与之前的环境隔离开来
	
	if((pid=fork())>=0)
	{
		exit(0);
	}
	esle if(pid==0)
	{
		setsid();.......如果不是会话组组长,那么就会脱去终端。
		if(fork()==0)....避免后台为其分配一个终端。
		{
			...
		}
		
	}